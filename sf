#!/bin/bash

set -o nounset

# =============================================
#  Global config of the application
# =============================================

PRG="$BASH_SOURCE"
while [ -h "$PRG" ] ; do
  ls=$(ls -ld "$PRG")
  link=$(expr "$ls" : '.*-> \(.*\)$')
  if expr "$link" : '/.*' > /dev/null; then
    PRG="$link"
  else
    PRG=$(dirname "$PRG")"/$link"
  fi
done

ROOT_PATH="."
if [ -x "$(command -v realpath)" ]; then
  ROOT_PATH=$(realpath "$(dirname "$PRG")")
fi

set -o allexport
[[ -f $ROOT_PATH/.env ]] && source $ROOT_PATH/.env
set +o allexport

# =============================================
#  Helper that describes all functionalities
# =============================================

if [[ $# -eq 0 ]] || [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
  echo "$(basename "$0") -- program to deal with $APP_NAME ecosystem
where:
  -h            show this help text"
  while read option name default help; do
    printf "  %s=%-10s %s  (default: $default)\n" $option "<$name>" "$(sed -e 's/^"//' -e 's/"$//' <<<"$help")"
  done < params.txt
  exit 0
fi

# =============================================
# Get script parameters
# =============================================

while read option name default help; do
  eval "$name=$default"
done < $ROOT_PATH/params.txt

while read; do
  while read option name default help; do
    if [[ $# -gt 2 ]]; then
      if [[ "$1" == "$option" ]]; then
        eval "$name=$2"
        shift 2
      fi
    fi
  done < $ROOT_PATH/params.txt
done < $ROOT_PATH/params.txt

set -o allexport
[[ -f $ROOT_PATH/.env.$ENV ]] && source $ROOT_PATH/.env.$ENV
set +o allexport

if [[ "$TAG" != "not-set" ]] && [[ ! "$TAG" =~ ^[0-9]+\.[0-9]+\.[0-9]+ ]]; then
  echo "tag format should be Semantic Versioning compliant x.x.x"
  exit 1
fi

CMD="$1"

shift

# =============================================
# Set variables for env
# =============================================

if [[ "$ENV" == "production" ]]; then
	SCALINGO_APP=$APP_NAME-backend
elif [[ ! "$ENV" == "development" ]]; then
	SCALINGO_APP=$APP_NAME-backend-$ENV
fi

# =============================================
# Utilities functions
# =============================================

function confirm {
 read -p "$1 (y/n) : " -n 1 -r
 echo
 if [[ ! $REPLY =~ ^[Yy]$ ]]
 then
   exit
 fi
}

function ensure_remote {
  if [[ "$ENV" == "development" ]]; then
    echo "$1"
    exit 3
  fi
}

export GIT_TAG=`cd "$ROOT_PATH/api" && git describe --tags --abbrev=0`

# =============================================
# Local commands : use Docker
# =============================================

# Run alembic migration
# Need to specify what alembic command you want to execute
# Example: ./$COMMAND_NAME alembic upgrade HEAD
if [[ "$CMD" == "alembic" ]]; then
  RUN='docker exec $APP_NAME-api-$MODE bash -c "cd /opt/api && PYTHONPATH=. alembic '"$*"'"'

# Connect to API container
elif [[ "$CMD" == bash ]]; then
	if [[ "$ENV" == "development" ]]; then
		RUN='docker exec -it $APP_NAME-api-$MODE bash'
	else
		scalingo -a "$SCALINGO_APP" run "bash"
		exit
	fi

# Clean all type of data
elif [[ "$CMD" == clean ]]; then
  if [[ "$1" == "database" ]]; then
    RUN='docker exec $APP_NAME-api-$MODE bash -c "cd /opt/api && PYTHONPATH=. python scripts/manager.py clean -t=database";'
  elif [[ "$1" == "storage" ]]; then
    RUN='sudo rm -rf $ROOT_PATH/api/static/object_store_data;'
  fi

# Kill ALL docker containersy/
elif [[ "$CMD" == "kill-all-containers" ]]; then
  confirm "Warning: all your docker containers are going to be killed ?"
  RUN='docker kill $(docker ps -q)'

# Force docker-compose to build the docker images
elif [[ "$CMD" == rebuild ]]; then
  RUN='cd $ROOT_PATH;
       docker-compose -f docker-compose.$MODE.yml pull $*;
       docker-compose -f docker-compose.$MODE.yml build --no-cache $*;'

# Restart docker-compose up with forcing recreation and unmounting volumes
elif [[ "$CMD" == restart ]]; then
  RUN='cd $ROOT_PATH;
       docker-compose -f docker-compose.$MODE.yml down --volumes $*;
       sh scripts/start_$MODE.sh --force-recreate $*;'

# Start docker-compose up with adapted env variables or frontends with local env
elif [[ "$CMD" == start ]]; then
  if [[ "$MODE" == "serve-webapp" ]]; then
    RUN='cd $ROOT_PATH/webapp;
         yarn start;'
  else
    RUN='cd $ROOT_PATH;
         sh scripts/start_$MODE.sh $*;'
  fi

# Stop development containers
elif [[ "$CMD" == stop ]]; then
  RUN='cd $ROOT_PATH;
       docker-compose -f docker-compose.$MODE.yml stop $*;'


# Run tests for API
#elif [[ "$CMD" == "start-test-api" ]]; then
# if [[ $# == 0 ]]; then
#   confirm "Warning: your database will be wiped. Is this OK ?"
#    RUN='docker exec $APP_NAME-api-development bash -c "cd /opt/api && rm -rf static/object_store_data/thumbs/* && PYTHONPATH=. pytest --color=yes -rsx -v tests"'
# else
#    RUN='docker exec $APP_NAME-api-development bash -c "cd /opt/api && rm -rf static/object_store_data/thumbs/* && PYTHONPATH=. pytest --color=yes -rsx -v '"$*"'"'
# fi

# Run tests for end to end
# Need start-backend AND start-webapp in two other processes
#elif [[ "$CMD" == "start-test-end2end" ]]; then
#	APP_PATH=$ROOT_PATH/webapp
#	SANDBOX_NAME="ci"
#	if [[ $# == 0 ]]; then
#		confirm "Warning: your database will be wiped. Is this OK ?"
#	 	"$ROOT_PATH"/$COMMAND_NAME -e $ENV clean-$MODE database
#		"$ROOT_PATH"/$COMMAND_NAME -e $ENV sandbox --name="$SANDBOX_NAME"
#		RUN='cd $APP_PATH;
#       scripts/manager.js testcafe -b chrome:headless'
#	else
# 	RUN='cd $APP_PATH;
#        scripts/manager.js testcafe '"$*"
#	fi

# =============================================
# Deploy commands
# =============================================

# Deploy current version of backend
elif [[ "$CMD" == "deploy-backend" ]]; then
  cd "$ROOT_PATH"
  if [[ ! "$ENV" == 'production' ]] && [[ ! "$ENV" == 'staging' ]]; then
     echo "Can only deploy-backend in staging and production"
     exit
  fi
  commit_to_deploy=`git log -n 1 --pretty=format:%H`
  current_branch=$(git symbolic-ref -q HEAD)
  current_branch=${current_branch##refs/heads/}
  function exit_restoring_branch
    {
    git checkout "$current_branch"
    exit
    }

	scalingo -a $SCALINGO_APP env-set GIT_TAG=$GIT_TAG

  git fetch
  git checkout master
  git pull || exit_restoring_branch
  git checkout staging
  git pull || exit_restoring_branch
  git checkout production
  git pull || exit_restoring_branch
  if [[ `git tag -l --points-at $commit_to_deploy | wc -l` == 0 ]]; then
    echo "ERROR: Can only deploy tagged commits"
    exit_restoring_branch
  fi
  if [[ "$ENV" == "production" ]]; then
    staging_commit=`git log -n 1 --pretty=format:%H staging`
    if [[ "$staging_commit" != "$commit_to_deploy" ]]; then
      echo "ERROR: Can only deploy in production commits that are also deployed in staging"
      exit_restoring_branch
    fi
  fi
  git checkout $ENV
  git merge $commit_to_deploy
  git push origin $ENV
  exit_restoring_branch

elif [[ "$CMD" == "deploy-webapp" ]]; then
	ensure_remote "Deploy fontend cannot be run on the local environment. Use (for example) \"$COMMAND_NAME -e staging "$CMD"\"."

	APP_PATH=$ROOT_PATH/webapp
	cd $APP_PATH

	(set -a; source "$APP_PATH/config/run_envs/$ENV" && yarn build) || exit

	# Add generic redirects for netlify which work with everything routed to
	# index.htm and relative paths to main.js and main.css for phonegap
	JSPATH=`grep -o '\./static/js/main\.[a-z0-9]*\.js' build/index.html`
	JSHASH=`echo "$JSPATH" | cut -d\. -f 3`
	CSSPATH=`grep -o '\./static/css/main\.[a-z0-9]*\.css' build/index.html`
	CSSHASH=`echo "$CSSPATH" | cut -d\. -f 3`

	echo "/:path1/main.$JSHASH.js /$JSPATH 301" > build/_redirects
	echo "/:path1/:path2/main.$JSHASH.js /$JSPATH 301" >> build/_redirects
	echo "/:path1/:path2/:path3/main.$JSHASH.js /$JSPATH 301" >> build/_redirects
	echo "/:path1/:path2/:path3/:path4/main.$JSHASH.js /$JSPATH 301" >> build/_redirects
	echo "/:path1/:path2/:path3/:path4/:path5/main.$JSHASH.js /$JSPATH 301" >> build/_redirects
	echo "/:path1/:path2/:path3/:path4/:path5/:path6/main.$JSHASH.js /$JSPATH 301" >> build/_redirects

	echo "/:path1/main.$CSSHASH.css /$CSSPATH 301" >> build/_redirects
	echo "/:path1/:path2/main.$CSSHASH.css /$CSSPATH 301" >> build/_redirects
	echo "/:path1/:path2/:path3/main.$CSSHASH.css /$CSSPATH 301" >> build/_redirects
	echo "/:path1/:path2/:path3/:path4/main.$CSSHASH.css /$CSSPATH 301" >> build/_redirects
	echo "/:path1/:path2/:path3/:path4/:path5/main.$CSSHASH.css /$CSSPATH 301" >> build/_redirects
	echo "/:path1/:path2/:path3/:path4/:path5/:path6/main.$CSSHASH.css /$CSSPATH 301" >> build/_redirects

	cat "public/_redirects" >> build/_redirects

	GIT_VERSION=`git log -n 1 --pretty=format:%h`
	git diff-index HEAD --quiet --exit-code
	if [[ "$?" -gt "0" ]]; then
		GIT_VERSION="$GIT_VERSION*"
	fi
	sed -i -e "s/##VERSION##/"$GIT_VERSION"/" build/$JSPATH;

	netlify deploy -e "$ENV"

	delivery_date=`( date --version 2>/dev/null | grep -q GNU\  && date +'%F_%H-%M-%S%N' ) || ( which gdate &>/dev/null && gdate +'%F_%H-%M-%S%N' ) || ( which python &> /dev/null && python -c 'import datetime; print datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S%f")' ) || ( date +'%F_%H-%M-%S' )`
	delivery_date=${delivery_date:0:21}
	tagname="deployed-$ENV-$delivery_date"
	git tag $tagname
	git push origin $tagname
	exit

# =============================================
# Initialization commands
# =============================================

# Install new local environment
elif [[ "$CMD" == "install" ]]; then
  RUN='cd $ROOT_PATH/webapp;
			 yarn;'

# Create symlink to use "$(echo $COMMAND_NAME)" command (admin rights may be needed)
elif [[ "$CMD" == "symlink" ]]; then
	RUN='cd /usr/local/bin && ln -sf '"$(pwd)"'/$COMMAND_NAME $COMMAND_NAME && chmod +x $COMMAND_NAME && chmod +x '"$(pwd)"'/$COMMAND_NAME'

# =============================================
# Administration commands
# =============================================

# Connect to Postgresql database in command line
elif [[ "$CMD" == psql ]]; then
	COLUMNS=${COLUMNS:-''};
	if [[ "$ENV" == "development" ]]; then
    RUN='docker exec -it $APP_NAME-api-$MODE bash -c "COLUMNS=\"'$COLUMNS'\" psql -U '$DB_NAME'_user '$DB_NAME' $*"'
	else
		scalingo -a $SCALINGO_APP pgsql-console
		exit
  fi

# Open a python prompt in the specified environment
elif [[ "$CMD" == python ]]; then
	if [[ "$ENV" == "development" ]]; then
		RUN='docker exec -it $APP_NAME-api-$MODE bash -c "cd /opt/api && PYTHONPATH=. python -i scripts/shell.py '"$CMD $*"'"'
	else
		scalingo -a "$SCALINGO_APP" run "python -i scripts/shell.py"
		exit
	fi

# =============================================
# Python Scripts commands
# =============================================

# Run python scripts from api/scripts
else
  if [[ "$ENV" == "development" ]]; then
    RUN='docker exec $APP_NAME-api-$MODE bash -c "cd /opt/api && PYTHONPATH=. python scripts/manager.py '"$CMD $*"'"'
  else
    scalingo -a "$SCALINGO_APP" run 'python scripts/manager.py '"$CMD $*"''
    exit
  fi
fi

# =============================================
# Execute command
# =============================================

echo $RUN
eval $RUN
